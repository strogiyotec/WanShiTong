## Dynamic programming
**Definition** - solving complex problem by breaking it into multiple simple problems\
solve each of them independently, store result of each problem\

## Steps
1. Characterise the structure of an optimal solution
2. Recursive define the value of an optimal solution
3. Compute the value of an optimal solution typically in a bottom up fashion
4. Construct an optimal solution from computed information

General rule
> If algorithms can be solved be 2^n time
> then it could be solved using dynamic programming

## Memoization
Split task into sub tasks and keep result.


1. [Greedy Algorithms](Greedy)
2. [String similarity algorithms](Strings)

## Resources
 - [MIT lecture](https://people.eecs.berkeley.edu/~vazirani/algorithms/chap6.pdf)
 - [Greedy explanation](https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/handouts/120%20Guide%20to%20Greedy%20Algorithms.pdf)
 - [Cool blog about Leetcode](https://medium.com/@liyin2015)
 - [DP](https://jeffe.cs.illinois.edu/teaching/algorithms/book/03-dynprog.pdf)
 - [Visualization](https://github.com/algorithm-visualizer/algorithm-visualizer)



